# Resources

https://github.com/Cybermaxs/awesome-analyzers

https://johnkoerner.com/archive/ - good blog about analyzers

https://renniestechblog.com/information/45-modifying-roslyn-step-12-anonymizing-the-property-names - modifying roslyn



### Learn Roslyn Now!

Source: https://www.youtube.com/watch?v=wXXHd8gYqVg&index=1&list=PLxk7xaZWBdUT23QfaQTCJDG6Q1xx6uHdG



**Blue nodes** - Syntax nodes (broken down into other types)

**Green nodes** - Syntax tokens (cannot be broken into smaller pieces)

**White/Gray** - Trivia (not relevant for compilation - e.g. whitespace, comments...)



### Syntax nodes

Roslyn types are visible in the Syntax Visualizer.

Immutable

`With[PropertyName]` - F# like syntax for modifying special props

SyntaxFactory



### Syntax tokens

`.ToFullString()` - toString with trivia (tabs, spaces...)



### Syntax walkers

DFS walk

Visits only SyntaxNodes by default -changed via constructor arg `base(SyntaxWalkerDepth.Token)`

When visiting SyntaxNodes - call to base implementation is required (they handle the traversal deeper into the tree).



### Syntax rewriter

Builds up tree from the bottom.

`return null` - remove visited node

`return node` - return the same node, do not traverse deeper

Formater class - format syntax trees to look "human".

Replacing nodes using `.ReplaceNode()` silently breaks when called with node (to replace) from another tree (e.g. in a foreach)



### Semantic Model and Symbols

Semantic model contains information about individual symbols (e.g. classes, methods...) with information about their Assembly, namespace etc...

When program does not compile - SymbolInfo may contain multiple CandidateSymbols instead of just one Symbol

Caches info for further calls (GetDeclaredSymbols etc..) but SemanticModel itself is not cached.



### Workspaces

`MSBuildWorkspace`  - manipulating VS Solutions on disc

`VisualStudioWorkspace` - manipulating live VS solution (e.g. from a VS plugin)

`AdHocWorkspace` - testing workspace, no need to call `TryApplyChanges` to apply changes



### VS Analyters

Nuget package or vsix addon



### TODO

- [ ] Conditional build with Roslyn locally linked
- [ ] IFlowCaptureOperation



## Data Flow API

Repository with source code:  https://github.com/dotnet/roslyn/blob/features/dataflow

HighLevel overview of IOperation based CFG: https://github.com/dotnet/roslyn/issues/24104

Unshipped APIs: https://github.com/dotnet/roslyn/blob/features/dataflow/src/Compilers/Core/Portable/PublicAPI.Unshipped.txt

### IOperation

Represents language semantics. Prevously represented as `IStatement` and `IExpression`, now merged into `IOperation`

Different syntax with same semantics (e.g. `If` statement and Conditional expression (ternary operator)) results in the same `IOperation` type. (e.g. `IConditionalOperation`)

```c#
var tree = compilation.SyntaxTrees[0];
var model = compilation.GetSemanticModel(tree);
var syntaxNode = GetSyntaxNodeOfTypeForBinding<TSyntaxNode>(GetSyntaxNodeList(tree));
model.GetOperation(syntaxNode);
```

`.GetOpetation(syntaxNode)` returns IOperation tree of the `syntaxNode`. This tree is unlowerer - e.g. `foreach` is represented by `IForEachLoopOperation` and `await` by `IAwaitOperation`.

`OperationVisitor` and `OperationWalker` are available for traversing the IOperations tree.

Operations visitor: https://github.com/dotnet/roslyn/blob/88801fa234db8f1bd16b30c04971311915a04cd7/src/Test/Utilities/Portable/Compilation/TestOperationVisitor.cs

#### Members

`Syntax` - Link to SyntaxNode that created this IOperation

`IsImplicit` - generated by compiler

`Parent\Children` - IOperations hierarchy



### IOperation based Control Flow Graph (CFG)

**Prototype, unshipped API, requires `flow-analysis` feature flag to enable**.

Method `SemanticModel.GetControlFlowGraph(oper)` returns **semi-lowered**, **packed** CFG where each `BasicBlock` contains List of `IOperation`. This list doesn't have any control flow operations inside of it. 

All of the operations within a basic block will always execute once control enters the basic block. All conditional operations - loops, if-else statements, conditional expressions have been lowered to a set of simpler operations. 

Packing happens when two different basic blocks are unconditionally executed after each other and their region is the same. E.g. `int i; {i = 10;}{i = 20;}` would get packed into one BB with one (non-root) Region.

#### ControlFlowGraph

`Root` - Links to Root Region

`Blosks` - List of Blocks

 #### BasicBlock

`Kind` -  Entry / Exit / Block (represents intermediate block)

`Statements` -  Array of IOperations

`Conditional` - Conditional branch

`Next` - Target of an unconditional branch

`Region` -  reffers to enclosing `Region` and

`Predecessors` -list of predecessors.

#### IFlowCaptureOperation

Represents captured variable caused by lowering. E.g. when lowering ternary operator.

#### Region

Region enclosing set of BasicBlock(s). Multiple regions can be nested.

`Kind `- `Kind.Locals` for local symbols (e.g. local variables), `Kind.Filter` for exception filter, `Kind.Root` representing Root Region.

`Enclosing` - enclosing region.

`Regions ` - list child regions

##### Example

```c#
{ int i; i = 10; }
{ int i; i = 20; }
```

Results in four (with two intermediate) `BasicBlock`s with two different `Locals` `Region`s (variable i is different in each region) and one enclosing `Root` region.





## Getting latest roslyn:

1. Get Moniker + Version from: https://github.com/dotnet/roslyn/blob/features/dataflow/build/Targets/Versions.props 
2. Check PublishData.json: https://github.com/dotnet/roslyn/blob/master/build/config/PublishData.json
3. See if package is on public myget:
   https://dotnet.myget.org/feed/roslyn/package/nuget/ [Package name]
   e.g. https://dotnet.myget.org/feed/roslyn/package/nuget/Microsoft.CodeAnalysis.CSharp.Scripting
4. Ctrl+F for moniker/version combination in the package history (ordered by version).



```c#
protected static void VerifyFlowGraphForTest<TSyntaxNode>(CSharpCompilation compilation, string expectedFlowGraph)
    where TSyntaxNode : SyntaxNode
        {
            var tree = compilation.SyntaxTrees[0];
            var model = compilation.GetSemanticModel(tree);
            SyntaxNode syntaxNode = GetSyntaxNodeOfTypeForBinding<TSyntaxNode>(GetSyntaxNodeList(tree));

            Operations.ControlFlowGraph graph = SemanticModel.GetControlFlowGraph((Operations.IBlockOperation)model.GetOperation(syntaxNode));
            ControlFlowGraphVerifier.VerifyGraph(compilation, expectedFlowGraph, graph);
        }	
```



## Using Local Build of (some) Roslyn libraries

Some libs are not shipped as nuget packages - e.g. `Roslyn.Test.Utilities.dll`, but they contain usefull classes for debugging and testing code which uses IOperations and CFGs. For example `OperationTreeVerifier.GetOperationTree` pretty-prints the whole IOperations tree.

1. Reference the required library directly from the build output of Roslyn `\roslyn\Binaries\Debug\Dlls\TestUtilities\net46\Roslyn.Test.Utilities.dll`.

Localy built roslyn assemblies have their version changed to **42.42.42.42**.

2. Add references (again from roslyn directory) for all dependencies that are causing conflict between libraries referenced from the nuget packages and the same libraries (but with version 42.42.42.42) referenced by the localy-built roslyn library.

3. Add BindingRedirect for conflicting libraries (resolve conflict between versions by redirecting to version 42.42.42.42)

   ```xml
   <dependentAssembly>
   	<assemblyIdentity name="Microsoft.CodeAnalysis.CSharp" publicKeyToken="31bf3856ad364e35" culture="neutral" />
   	<bindingRedirect oldVersion="0.0.0.0-42.42.42.42" newVersion="42.42.42.42" />
   </dependentAssembly>
   ```

4. Project should build without any errors now.

5. We can call the `OperationsTreeVerifier`

   ```c#
   var operStr = OperationTreeVerifier.GetOperationTree(compilation, oper);
   ```

   `operStr` now contains the pretty-printed tree:

   ```
   IBlockOperation (2 statements) (OperationKind.Block, Type: null) ...
     IBlockOperation (2 statements, 1 locals) (OperationKind.Block, Type: null) ...
       Locals: Local_1: System.Int32 i
       IVariableDeclarationGroupOperation (1 declarations) ...
         IVariableDeclarationOperation (1 declarators) ...
           Declarators:
    ....
   ```

   