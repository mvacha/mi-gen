## Control Flow Graph API

Repository with source code:  https://github.com/dotnet/roslyn/blob/features/dataflow

HighLevel overview of IOperation based CFG: https://github.com/dotnet/roslyn/issues/24104

Unshipped APIs: https://github.com/dotnet/roslyn/blob/features/dataflow/src/Compilers/Core/Portable/PublicAPI.Unshipped.txt

### IOperation

Represents language semantics. Prevously represented as `IStatement` and `IExpression`, now merged into `IOperation`

Different syntax with same semantics (e.g. `If` statement and Conditional expression (ternary operator)) results in the same `IOperation` type. (e.g. `IConditionalOperation`)

```c#
var tree = compilation.SyntaxTrees[0];
var model = compilation.GetSemanticModel(tree);
var syntaxNode = GetSyntaxNodeOfTypeForBinding<TSyntaxNode>(GetSyntaxNodeList(tree));
model.GetOperation(syntaxNode);
```

`.GetOpetation(syntaxNode)` returns IOperation tree of the `syntaxNode`. This tree is unlowerer - e.g. `foreach` is represented by `IForEachLoopOperation` and `await` by `IAwaitOperation`.

`OperationVisitor` and `OperationWalker` are available for traversing the IOperations tree.

Operations visitor: https://github.com/dotnet/roslyn/blob/88801fa234db8f1bd16b30c04971311915a04cd7/src/Test/Utilities/Portable/Compilation/TestOperationVisitor.cs

#### Members

`Syntax` - Link to SyntaxNode that created this IOperation

`IsImplicit` - generated by compiler

`Parent\Children` - IOperations hierarchy



### IOperation based Control Flow Graph (CFG)

**Prototype, unshipped API, requires `flow-analysis` feature flag to enable**.

Method `SemanticModel.GetControlFlowGraph(oper)` returns **semi-lowered**, **packed** CFG where each `BasicBlock` contains List of `IOperation`. This list doesn't have any control flow operations inside of it. 

All of the operations within a basic block will always execute once control enters the basic block. All conditional operations - loops, if-else statements, conditional expressions have been lowered to a set of simpler operations. 

Packing happens when two different basic blocks are unconditionally executed after each other and their region is the same. E.g. `int i; {i = 10;}{i = 20;}` would get packed into one BB with one (non-root) Region.

#### ControlFlowGraph

`Root` - Links to Root Region

`Blosks` - List of Blocks

#### BasicBlock

`Kind` -  Entry / Exit / Block (represents intermediate block)

`Statements` -  Array of IOperations

`Conditional` - Conditional branch

`Next` - Target of an unconditional branch

`Region` -  reffers to enclosing `Region` and

`Predecessors` -list of predecessors.

#### IFlowCaptureOperation

Represents captured variable caused by lowering. E.g. when lowering ternary operator.

#### Region

Region enclosing set of BasicBlock(s). Multiple regions can be nested.

`Kind `- `Kind.Locals` for local symbols (e.g. local variables), `Kind.Filter` for exception filter, `Kind.Root` representing Root Region.

`Enclosing` - enclosing region.

`Regions ` - list child regions

##### Example

```c#
{ int i; i = 10; }
{ int i; i = 20; }
```

Results in four (with two intermediate) `BasicBlock`s with two different `Locals` `Region`s (variable i is different in each region) and one enclosing `Root` region.





